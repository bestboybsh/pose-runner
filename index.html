<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pose Runner (Stable)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, select { font-size: 16px; padding: 10px 12px; }
    #wrap { display: grid; gap: 12px; grid-template-columns: 1fr; max-width: 980px; }
    #video { width: min(92vw, 980px); background: #111; border-radius: 12px; }
    #game { width: min(92vw, 980px); height: auto; border-radius: 12px; background: #111; }
    #hud { white-space: pre-wrap; background: #f6f6f6; padding: 12px; border-radius: 12px; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; background: #eee; margin-right: 6px; }
    .muted { color: #666; }
  </style>
</head>
<body>
  <h2>Pose Runner (Stable)</h2>

  <div id="wrap">
    <div class="row">
      <button id="btnStart">Start camera</button>
      <button id="btnLoadPose" disabled>Load pose</button>
      <button id="btnCal" disabled>Calibrate</button>
      <button id="btnStop" disabled>Stop</button>

      <label class="pill">
        Facing
        <select id="facing">
          <option value="user">Front</option>
          <option value="environment">Back</option>
        </select>
      </label>

      <span class="pill">Status: <b id="status">INIT</b></span>
      <span class="pill">Score: <b id="score">0</b></span>
      <span class="pill">FPS: <b id="fps">0</b></span>
    </div>

    <div class="muted">
      Controls: Jump = real jump or Space. Duck = squat or ArrowDown (hold). Restart = R.
      Flow: Start camera → Load pose → stand still 1s → Calibrate.
    </div>

    <video id="video" autoplay playsinline muted></video>
    <canvas id="game" width="980" height="420"></canvas>

    <div id="hud"></div>
  </div>

  <script>
    const btnStart = document.getElementById("btnStart");
    const btnLoadPose = document.getElementById("btnLoadPose");
    const btnCal = document.getElementById("btnCal");
    const btnStop = document.getElementById("btnStop");
    const facingSel = document.getElementById("facing");
    const statusEl = document.getElementById("status");
    const scoreEl = document.getElementById("score");
    const fpsEl = document.getElementById("fps");
    const hud = document.getElementById("hud");
    const video = document.getElementById("video");
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    function setStatus(s) { statusEl.textContent = s; }
    function log(msg) {
      hud.textContent += msg + "\n";
      hud.textContent = hud.textContent.slice(-6000);
      console.log(msg);
    }

    // ---------- Camera ----------
    let stream = null;

    async function startCamera() {
      hud.textContent = "";
      setStatus("CAMERA_START");
      log("Starting camera...");

      if (!navigator.mediaDevices?.getUserMedia) {
        log("ERROR: getUserMedia not supported.");
        setStatus("CAMERA_FAIL");
        return;
      }

      if (stream) stopCamera();

      try {
        stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: facingSel.value },
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });

        video.srcObject = stream;
        await video.play();

        log("Camera OK.");
        setStatus("CAMERA_OK");

        btnStop.disabled = false;
        btnLoadPose.disabled = false;
      } catch (e) {
        log("ERROR: " + (e?.name || "Unknown") + " " + (e?.message || e));
        setStatus("CAMERA_FAIL");
      }
    }

    function stopCamera() {
      if (stream) stream.getTracks().forEach(t => t.stop());
      stream = null;
      video.srcObject = null;
      setStatus("STOPPED");
      log("Stopped camera.");

      btnStop.disabled = true;
      btnLoadPose.disabled = true;
      btnCal.disabled = true;

      stopGameLoop();
    }

    // ---------- Pose (lazy load) ----------
    let vision = null;
    let poseLandmarker = null;
    let poseLoaded = false;

    async function loadPoseEngine() {
      if (poseLoaded) {
        log("Pose already loaded.");
        return;
      }
      setStatus("POSE_LOADING");
      log("Loading pose engine...");

      try {
        vision = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14");
        const { PoseLandmarker, FilesetResolver } = vision;

        const fileset = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
        );

        poseLandmarker = await PoseLandmarker.createFromOptions(fileset, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task"
          },
          runningMode: "VIDEO",
          numPoses: 1
        });

        poseLoaded = true;
        setStatus("POSE_OK");
        log("Pose engine OK.");

        btnCal.disabled = false;
      } catch (e) {
        log("POSE LOAD ERROR: " + (e?.message || e));
        setStatus("POSE_FAIL");
      }
    }

    // ---------- Calibration + action detection ----------
    const LM = {
      L_SHOULDER: 11, R_SHOULDER: 12,
      L_HIP: 23, R_HIP: 24,
    };

    function getLm(landmarks, idx) {
      const p = landmarks?.[idx];
      return p ? { x: p.x, y: p.y, v: p.visibility ?? 1 } : null;
    }

    function avgY(...pts) {
      const ok = pts.filter(p => p && p.v > 0.3);
      if (!ok.length) return null;
      return ok.reduce((s, p) => s + p.y, 0) / ok.length;
    }

    let cal = {
      ready: false,
      torsoY: null,
      hipY: null,
      squatHipDelta: 0.10,
      jumpTorsoDelta: 0.06
    };

    function calibrateFromPose(landmarks) {
      const ls = getLm(landmarks, LM.L_SHOULDER);
      const rs = getLm(landmarks, LM.R_SHOULDER);
      const lh = getLm(landmarks, LM.L_HIP);
      const rh = getLm(landmarks, LM.R_HIP);

      const shoulderY = avgY(ls, rs);
      const hipY = avgY(lh, rh);
      if (shoulderY == null || hipY == null) {
        log("Calibrate failed: full body not visible enough.");
        return false;
      }

      cal.torsoY = (shoulderY + hipY) / 2;
      cal.hipY = hipY;
      cal.ready = true;

      log(`Calibrated. torsoY=${cal.torsoY.toFixed(3)} hipY=${cal.hipY.toFixed(3)}`);
      setStatus("RUNNING");
      return true;
    }

    function detectActions(landmarks) {
      if (!cal.ready) return { jump: false, duck: false };

      const ls = getLm(landmarks, LM.L_SHOULDER);
      const rs = getLm(landmarks, LM.R_SHOULDER);
      const lh = getLm(landmarks, LM.L_HIP);
      const rh = getLm(landmarks, LM.R_HIP);

      const torsoY = avgY(ls, rs, lh, rh);
      const hipY = avgY(lh, rh);
      if (torsoY == null || hipY == null) return { jump: false, duck: false };

      const jump = (cal.torsoY - torsoY) > cal.jumpTorsoDelta; // y smaller => up
      const duck = (hipY - cal.hipY) > cal.squatHipDelta;      // y larger => down

      return { jump, duck };
    }

    function capturePoseOnce() {
      if (!poseLandmarker) return null;
      if (video.readyState < 2) return null;
      const now = performance.now();
      const res = poseLandmarker.detectForVideo(video, now);
      return res?.landmarks?.[0] || null;
    }

    // ---------- Runner game ----------
    const G = {
      t: 0,
      score: 0,
      speed: 6,
      gravity: 0.9,
      groundY: 340,
      player: { x: 120, y: 340, vy: 0, h: 46, w: 30, duck: false },
      obstacles: [],
      spawnCd: 0,
      over: false
    };

    function resetGame() {
      G.t = 0;
      G.score = 0;
      G.speed = 6;
      G.player.y = G.groundY;
      G.player.vy = 0;
      G.player.duck = false;
      G.obstacles = [];
      G.spawnCd = 0;
      G.over = false;
      scoreEl.textContent = "0";
      log("Game reset.");
    }

    function spawnObstacle() {
      const type = Math.random() < 0.65 ? "low" : "high";
      const w = type === "low" ? 22 : 40;
      const h = type === "low" ? 48 : 26;
      const y = type === "low" ? G.groundY : (G.groundY - 70);
      G.obstacles.push({ x: canvas.width + 20, y, w, h, type });
    }

    function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    // keyboard fallback
    const keys = { space: false, down: false };
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") keys.space = true;
      if (e.code === "ArrowDown") keys.down = true;
      if (e.code === "KeyR") resetGame();
    });
    window.addEventListener("keyup", (e) => {
      if (e.code === "Space") keys.space = false;
      if (e.code === "ArrowDown") keys.down = false;
    });

    function updateGame(actions) {
      if (G.over) return;

      G.t += 1;
      if (G.t % 240 === 0) G.speed += 0.6;

      const wantJump = actions.jump || keys.space;
      const wantDuck = actions.duck || keys.down;

      G.player.duck = wantDuck && (G.player.y >= G.groundY);

      if (wantJump && G.player.y >= G.groundY) G.player.vy = -14;

      G.player.vy += G.gravity;
      G.player.y += G.player.vy;
      if (G.player.y > G.groundY) {
        G.player.y = G.groundY;
        G.player.vy = 0;
      }

      G.spawnCd -= 1;
      if (G.spawnCd <= 0) {
        spawnObstacle();
        G.spawnCd = 70 + Math.floor(Math.random() * 70);
      }

      for (const ob of G.obstacles) ob.x -= G.speed;
      G.obstacles = G.obstacles.filter(ob => ob.x > -100);

      const ph = G.player.duck ? 26 : 46;
      const py = G.player.duck ? (G.player.y - 26) : (G.player.y - 46);

      for (const ob of G.obstacles) {
        const hit = aabb(G.player.x, py, G.player.w, ph, ob.x, ob.y - ob.h, ob.w, ob.h);
        if (hit) {
          G.over = true;
          setStatus("GAME_OVER (R)");
          log("Game over. Press R to restart.");
          break;
        }
      }

      G.score += 1;
      scoreEl.textContent = String(Math.floor(G.score / 6));
    }

    function drawGame(actions) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#222";
      ctx.fillRect(0, G.groundY + 10, canvas.width, 4);

      for (const ob of G.obstacles) {
        ctx.fillStyle = ob.type === "low" ? "#e5e5e5" : "#bdbdbd";
        ctx.fillRect(ob.x, ob.y - ob.h, ob.w, ob.h);
      }

      const ph = G.player.duck ? 26 : 46;
      const py = G.player.duck ? (G.player.y - 26) : (G.player.y - 46);
      ctx.fillStyle = "#8bd3ff";
      ctx.fillRect(G.player.x, py, G.player.w, ph);

      ctx.fillStyle = "#fff";
      ctx.font = "16px system-ui";
      const label = [
        cal.ready ? "" : "Not calibrated",
        actions.jump ? "JUMP" : "",
        actions.duck ? "DUCK" : "",
        G.over ? "GAME OVER" : ""
      ].filter(Boolean).join(" | ");
      ctx.fillText(label, 16, 28);
    }

    // ---------- Game/Pose loop ----------
    let rafId = null;
    let lastPoseTs = 0;
    let lastFpsTick = performance.now();
    let frames = 0;

    function startGameLoop() {
      if (rafId) return;
      setStatus(cal.ready ? "RUNNING" : "READY");
      resetGame();

      const tick = () => {
        rafId = requestAnimationFrame(tick);

        // FPS
        frames += 1;
        const now = performance.now();
        if (now - lastFpsTick >= 1000) {
          fpsEl.textContent = String(frames);
          frames = 0;
          lastFpsTick = now;
        }

        let actions = { jump: false, duck: false };

        if (poseLandmarker && video.readyState >= 2 && !G.over) {
          if (now - lastPoseTs > 33) { // ~30Hz
            lastPoseTs = now;
            const res = poseLandmarker.detectForVideo(video, now);
            const lm = res?.landmarks?.[0];
            if (lm) actions = detectActions(lm);
          }
        }

        updateGame(actions);
        drawGame(actions);
      };

      rafId = requestAnimationFrame(tick);
      log("Game loop started.");
    }

    function stopGameLoop() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      fpsEl.textContent = "0";
      log("Game loop stopped.");
    }

    // ---------- Buttons ----------
    btnStart.addEventListener("click", startCamera);
    btnLoadPose.addEventListener("click", async () => {
      await loadPoseEngine();
      if (poseLoaded) startGameLoop();
    });

    btnCal.addEventListener("click", () => {
      const lm = capturePoseOnce();
      if (!lm) {
        log("Calibrate failed: no pose detected. Make sure full body is visible and light is good.");
        return;
      }
      const ok = calibrateFromPose(lm);
      if (ok) resetGame();
    });

    btnStop.addEventListener("click", () => {
      stopGameLoop();
      stopCamera();
    });

    window.addEventListener("load", () => {
      log("JS loaded.");
      log("isSecureContext: " + window.isSecureContext);
      log("Tip: Start camera → Load pose → Calibrate.");
    });
  </script>
</body>
</html>
